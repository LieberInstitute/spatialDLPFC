Adding LIBD modules
Loading git
Loading LIBD module for git-status-size/github
Loading LIBD module for git-lfs/2.8.0
Loading LIBD module for rmate/1.5.9
Loading LIBD module for ruby/2.6.4p104
Loading conda_R/4.2.x
**** Job starts ****
Wed Dec  7 13:57:56 EST 2022
**** JHPCE info ****
User: lhuuki
Job id: 1284209
Job name: layer_correlation_annotation
Hostname: compute-149.cm.cluster
Task id: undefined
Unloading conda_R/4.2.x
Loading conda_R/4.2.x

Currently Loaded Modules:
  1) matlab/R2019a     6) COMMUNITY_CENTOS7_DEFAULT_ENV  11) ruby/2.6.4p104
  2) stata/17          7) JHPCE_CENTOS7_DEFAULT_ENV      12) rmate/1.5.9
  3) JHPCE_tools/1.0   8) git-status-size/github         13) conda/3-4.11.0
  4) sge/8.1.9         9) git/2.28.0                     14) conda_R/4.2.x
  5) gcc/4.4.7        10) git-lfs/2.8.0

 

Loading required package: SpatialExperiment
Loading required package: SingleCellExperiment
Loading required package: SummarizedExperiment
Loading required package: MatrixGenerics
Loading required package: matrixStats

Attaching package: ‘MatrixGenerics’

The following objects are masked from ‘package:matrixStats’:

    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,
    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,
    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,
    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,
    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,
    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,
    colWeightedMeans, colWeightedMedians, colWeightedSds,
    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,
    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,
    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,
    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,
    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,
    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,
    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,
    rowWeightedSds, rowWeightedVars

Loading required package: GenomicRanges
Loading required package: stats4
Loading required package: BiocGenerics

Attaching package: ‘BiocGenerics’

The following objects are masked from ‘package:stats’:

    IQR, mad, sd, var, xtabs

The following objects are masked from ‘package:base’:

    anyDuplicated, aperm, append, as.data.frame, basename, cbind,
    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,
    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,
    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,
    Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort,
    table, tapply, union, unique, unsplit, which.max, which.min

Loading required package: S4Vectors

Attaching package: ‘S4Vectors’

The following objects are masked from ‘package:base’:

    expand.grid, I, unname

Loading required package: IRanges
Loading required package: GenomeInfoDb
Loading required package: Biobase
Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.


Attaching package: ‘Biobase’

The following object is masked from ‘package:MatrixGenerics’:

    rowMedians

The following objects are masked from ‘package:matrixStats’:

    anyMissing, rowMedians

── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──
✔ ggplot2 3.4.0      ✔ purrr   0.3.5 
✔ tibble  3.1.8      ✔ dplyr   1.0.10
✔ tidyr   1.2.1      ✔ stringr 1.5.0 
✔ readr   2.1.3      ✔ forcats 0.5.2 
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::collapse()   masks IRanges::collapse()
✖ dplyr::combine()    masks Biobase::combine(), BiocGenerics::combine()
✖ dplyr::count()      masks matrixStats::count()
✖ dplyr::desc()       masks IRanges::desc()
✖ tidyr::expand()     masks S4Vectors::expand()
✖ dplyr::filter()     masks stats::filter()
✖ dplyr::first()      masks S4Vectors::first()
✖ dplyr::lag()        masks stats::lag()
✖ ggplot2::Position() masks BiocGenerics::Position(), base::Position()
✖ purrr::reduce()     masks GenomicRanges::reduce(), IRanges::reduce()
✖ dplyr::rename()     masks S4Vectors::rename()
✖ dplyr::slice()      masks IRanges::slice()
Loading required package: rafalib
Loading required package: grid
========================================
ComplexHeatmap version 2.14.0
Bioconductor page: http://bioconductor.org/packages/ComplexHeatmap/
Github page: https://github.com/jokergoo/ComplexHeatmap
Documentation: http://jokergoo.github.io/ComplexHeatmap-reference

If you use it in published research, please cite either one:
- Gu, Z. Complex Heatmap Visualization. iMeta 2022.
- Gu, Z. Complex heatmaps reveal patterns and correlations in multidimensional 
    genomic data. Bioinformatics 2016.


The new InteractiveComplexHeatmap package can directly export static 
complex heatmaps into an interactive Shiny app with zero effort. Have a try!

This message can be suppressed by:
  suppressPackageStartupMessages(library(ComplexHeatmap))
========================================

here() starts at /dcs04/lieber/lcolladotor/spatialDLPFC_LIBD4035/spatialDLPFC
$k02
                  Sp02D01  Sp02D02
ENSG00000237491 -1.023457 1.023457
ENSG00000228794 -3.536138 3.536138
ENSG00000188976 -2.159858 2.159858
ENSG00000187961 -3.276875 3.276875
ENSG00000188290 -4.093876 4.093876
ENSG00000187608 -1.129186 1.129186

$k07
                  Sp07D01   Sp07D02  Sp07D03    Sp07D04    Sp07D05    Sp07D06
ENSG00000237491 -2.327270 2.6956251 1.512644  1.4265940  0.6268180  0.8820517
ENSG00000228794 -1.172673 2.4138598 2.521893  2.0857724 -3.1722122  2.4891281
ENSG00000188976 -3.624565 1.0056233 1.727466  1.6597807  0.3748586  1.8649531
ENSG00000187961 -2.601838 2.5060835 2.370181  2.0156721 -0.1877426  2.1305837
ENSG00000188290  2.946213 2.0276457 1.110377  1.2912877 -3.2459669 -0.7179326
ENSG00000187608  3.494265 0.1436516 3.055365 -0.5956951  0.6160400 -1.9896895

$k09
                  Sp09D01   Sp09D02   Sp09D03    Sp09D04   Sp09D05     Sp09D06
ENSG00000237491 -5.683249 -1.592857  2.695610  1.5569168 1.3352650 -1.91060561
ENSG00000228794 -8.227898 -0.336100  2.156830  2.0035707 2.4894750 -3.61607196
ENSG00000188976 -5.464019 -4.189809  0.909507  1.9152632 1.8595393  0.01984357
ENSG00000187961 -7.643391 -2.323352  2.195490  2.1176496 2.0449522 -0.90563892
ENSG00000188290  6.541200  1.832584  1.138951  0.4337303 0.8710892 -6.15801629
ENSG00000187608  2.213854  2.065798 -1.345697 -1.5676017 1.4126586 -0.49757373

$k16
                  Sp16D01    Sp16D02  Sp16D03    Sp16D04    Sp16D05    Sp16D06
ENSG00000228794 -5.278123 -0.3400075 2.780562  2.3367865 2.27266236 -5.1838438
ENSG00000188976 -3.259529 -0.8702588 1.643083  2.0055282 1.53292850 -5.5398097
ENSG00000188290  5.653713  2.3099194 1.316982  0.8726243 0.03559905 -5.1836073
ENSG00000187608  3.489669  2.4489797 1.628964 -0.9314217 2.36574277 -0.7463618
ENSG00000188157 -3.194281  0.1043479 2.089457  1.5636269 1.93767673  0.3027435
ENSG00000131591 -3.344616 -2.3029285 1.040413  1.4301234 0.76427520 -0.9520200

$k28
                   Sp28D01     Sp28D02   Sp28D03    Sp28D04   Sp28D05
ENSG00000228794 -0.6453651  1.93788622 2.3481166  2.2961203 2.1215753
ENSG00000188976  0.9391346  1.49749549 1.4187580  2.1190569 1.6727954
ENSG00000188290 -1.9771211 -0.05317001 1.1571859  1.0142654 0.4293796
ENSG00000187608 -2.4051919  0.56923106 2.1214303 -0.6113597 2.6939843
ENSG00000188157 -0.6470931  1.73765195 2.2642578  1.9483886 2.3751878
ENSG00000078808 -0.6414705  1.16506963 0.5521013  0.3083298 1.0445658
                   Sp28D06
ENSG00000228794 -0.1859678
ENSG00000188976  0.5677890
ENSG00000188290 -1.6081217
ENSG00000187608  1.0896171
ENSG00000188157  1.8681183
ENSG00000078808  1.4507622

snapshotDate(): 2022-10-31
2022-12-07 13:58:33 loading file /users/lhuuki/.cache/R/BiocFileCache/6b24121203e_Human_DLPFC_Visium_modeling_results.Rdata%3Fdl%3D1
$k02
NULL

$k07
NULL

$k09
NULL

$k16
NULL

$k28
NULL

null device 
          1 
Joining, by = "cluster"
  cluster layer_confidence layer_label layer_abby
1 Sp09D01             good          L1        Vas
2 Sp09D02             good          L1         L1
3 Sp09D03             good          L2       L2/3
4 Sp09D04             good          L5         L5
5 Sp09D05             good          L3         L3
6 Sp09D06             good          WM         WM
7 Sp09D07             good          L6        L6A
8 Sp09D08             good          L4         L4
9 Sp09D09             good          WM         WM
Joining, by = "cluster"
  cluster layer_confidence layer_label layer_abby
1 Sp09D01             good          L1        Vas
2 Sp09D02             good          L1         L1
3 Sp09D03             good        L2/3       L2/3
4 Sp09D04             good          L5         L5
5 Sp09D05             good          L3         L3
6 Sp09D06             good          WM         WM
7 Sp09D07             good          L6        L6A
8 Sp09D08             good          L4         L4
9 Sp09D09             good          WM         WM

> fix_layer_order <- function(l) {
+     star <- ifelse(grepl("\\*", l), "*", "")
+     l <- gsub("L|\\*", "", l)
+     l <- sort(unlist(strsplit(l, "/")))
+     if (all(l == "WM")) {
+         return(paste0("WM", star))
+     }
+     l[[1]] <- paste0("L", l[[1]])
+     fix <- paste0(paste0(l, collapse = "/"), star)
+     return(fix)
+ }

> fix_layer_order2 <- Vectorize(fix_layer_order)
 [1] "Sp07D01 ~ L1"    "Sp09D01 ~ L1"    "Sp09D02 ~ L1"    "Sp16D01 ~ L1"   
 [5] "Sp16D02 ~ L1"    "Sp16D14 ~ L1"    "Sp28D11 ~ L1"    "Sp28D12 ~ L1"   
 [9] "Sp28D15 ~ L1"    "Sp28D23 ~ L1"    "Sp28D26 ~ L1"    "Sp28D27 ~ L1"   
[13] "Sp09D03 ~ L2"    "Sp16D08 ~ L2"    "Sp28D09 ~ L2"    "Sp07D02 ~ L2/3" 
[17] "Sp16D10 ~ L2/3"  "Sp02D02 ~ L3"    "Sp09D05 ~ L3"    "Sp16D03 ~ L3"   
[21] "Sp28D01 ~ L3"    "Sp28D02 ~ L3"    "Sp28D03 ~ L3"    "Sp28D08 ~ L3"   
[25] "Sp07D03 ~ L3/4"  "Sp16D09 ~ L3/4"  "Sp28D10 ~ L3/4"  "Sp28D24 ~ L3/4" 
[29] "Sp09D08 ~ L4"    "Sp16D05 ~ L4"    "Sp28D05 ~ L4"    "Sp28D22 ~ L4"   
[33] "Sp28D25 ~ L4"    "Sp07D04 ~ L5"    "Sp09D04 ~ L5"    "Sp16D04 ~ L5"   
[37] "Sp16D16 ~ L5"    "Sp28D04 ~ L5"    "Sp28D13 ~ L5"    "Sp28D19 ~ L5/6" 
[41] "Sp07D06 ~ L6"    "Sp09D07 ~ L6"    "Sp16D07 ~ L6"    "Sp16D12 ~ L6"   
[45] "Sp28D07 ~ L6"    "Sp28D14 ~ L6"    "Sp28D16 ~ L6/WM" "Sp02D01 ~ WM"   
[49] "Sp07D05 ~ WM"    "Sp07D07 ~ WM"    "Sp09D06 ~ WM"    "Sp09D09 ~ WM"   
[53] "Sp16D06 ~ WM"    "Sp16D11 ~ WM"    "Sp16D13 ~ WM"    "Sp16D15 ~ WM"   
[57] "Sp28D06 ~ WM"    "Sp28D17 ~ WM"    "Sp28D20 ~ WM"    "Sp28D28 ~ WM"   
   layer_annotation  n
1                L1 12
2                L2  3
3              L2/3  2
4                L3  7
5              L3/4  4
6                L4  5
7                L5  6
8              L5/6  1
9                L6  6
10            L6/WM  1
11               WM 13
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.apache.poi.util.SAXHelper (file:/jhpce/shared/jhpce/core/conda/miniconda3-4.11.0/envs/svnR-4.2.x/R/4.2.x/lib64/R/site-library/xlsxjars/java/poi-ooxml-3.10.1-20140818.jar) to method com.sun.org.apache.xerces.internal.util.SecurityManager.setEntityExpansionLimit(int)
WARNING: Please consider reporting this to the maintainers of org.apache.poi.util.SAXHelper
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
# A tibble: 7 × 3
  layer_long layer_short     n
  <chr>      <chr>       <int>
1 Layer1     L1             12
2 Layer2     L2              5
3 Layer3     L3             13
4 Layer4     L4              9
5 Layer5     L5              7
6 Layer6     L6              8
7 WM         WM             14
# A tibble: 1 × 2
  confidence     n
  <lgl>      <int>
1 TRUE          68
Saving 7 x 7 in image
[1] 0.9452202

> libd_intermediate_layer_colors <- c(`L1/2` = "#BF3889", 
+     `L2/3` = "#50DDAC", `L3/4` = "#8278B0", `L4/5` = "#BD8339", 
+     `L5/6` = "#FFB300", `L6/WM` = "#7A3D00")
           L1            L2            L3            L4            L5 
    "#F0027F"     "#377EB8"     "#4DAF4A"     "#984EA3"     "#FFD700" 
           L6            WM            NA           WM2          L1/2 
    "#FF7F00"     "#1A1A1A" "transparent"     "#666666"     "#BF3889" 
         L2/3          L3/4          L4/5          L5/6         L6/WM 
    "#50DDAC"     "#8278B0"     "#BD8339"     "#FFB300"     "#7A3D00" 

 *** caught segfault ***
address 0xc, cause 'memory not mapped'

Traceback:
 1: grep("^\\.\\.[0-9]+$", as.character(name))
 2: is.ddsym(sym)
 3: cmpSym(e, cb, cntxt, missingOK)
 4: cmp(e, cb, cntxt, setloc = FALSE)
 5: genCode(a, pcntxt, loc = cb$savecurloc())
 6: cb$putconst(genCode(a, pcntxt, loc = cb$savecurloc()))
 7: cmpCallArgs(args, cb, cntxt, nse)
 8: cmpCallSymFun(fun, args, call, cb, cntxt)
 9: cmpCall(e, cb, cntxt)
10: cmp(e, cb, cntxt, setloc = FALSE)
11: genCode(a, pcntxt, loc = cb$savecurloc())
12: cb$putconst(genCode(a, pcntxt, loc = cb$savecurloc()))
13: cmpCallArgs(args, cb, cntxt, nse)
14: cmpCallSymFun(fun, args, call, cb, cntxt)
15: cmpCall(e, cb, cntxt)
16: cmp(value, cb, ncntxt)
17: cmpSymbolAssign(symbol, value, superAssign, cb, cntxt)
18: h(e, cb, cntxt)
19: tryInline(call, cb, cntxt)
20: cmpCall(e, cb, cntxt)
21: cmp(subexp, cb, ncntxt, setloc = FALSE)
22: h(e, cb, cntxt)
23: tryInline(call, cb, cntxt)
24: cmpCall(e, cb, cntxt)
25: cmp(then.expr, cb, cntxt)
26: h(e, cb, cntxt)
27: tryInline(call, cb, cntxt)
28: cmpCall(e, cb, cntxt)
29: cmp(subexp, cb, ncntxt, setloc = FALSE)
30: h(e, cb, cntxt)
31: tryInline(call, cb, cntxt)
32: cmpCall(e, cb, cntxt)
33: cmp(e, cb, cntxt, setloc = FALSE)
34: genCode(body(f), ncntxt, loc = loc)
35: cmpfun(f)
36: doTryCatch(return(expr), name, parentenv, handler)
37: tryCatchOne(expr, names, parentenv, handlers[[1L]])
38: tryCatchList(expr, classes, parentenv, handlers)
39: tryCatch(cmpfun(f), error = function(e) {    notifyCompilerError(paste(e$message, "at", deparse(e$call)))    f})
40: compiler:::tryCmpfun(function (object, kr = 1, kc = 1, ...) {    if (ncol(object@matrix) == 0 || nrow(object@matrix) == 0) {        return(invisible(NULL))    }    row_order = object@row_order_list[[kr]]    column_order = object@column_order_list[[kc]]    gp = object@matrix_param$gp    border = object@matrix_param$border    use_raster = object@heatmap_param$use_raster    raster_device = object@heatmap_param$raster_device    raster_quality = object@heatmap_param$raster_quality    raster_device_param = object@heatmap_param$raster_device_param    raster_by_magick = object@heatmap_param$raster_by_magick    raster_magick_filter = object@heatmap_param$raster_magick_filter    if (length(raster_device_param) == 0)         raster_device_param = list()    pushViewport(viewport(name = paste(object@name, "heatmap_body",         kr, kc, sep = "_"), ...))    mat = object@matrix[row_order, column_order, drop = FALSE]    oe = try(col_matrix <- map_to_colors(object@matrix_color_mapping,         mat), silent = TRUE)    if (inherits(oe, "try-error")) {        col_matrix = matrix(NA, nrow = nrow(mat), ncol = ncol(mat))    }    nc = ncol(mat)    nr = nrow(mat)    x = (seq_len(nc) - 0.5)/nc    y = (rev(seq_len(nr)) - 0.5)/nr    expand_index = expand.grid(seq_len(nr), seq_len(nc))    cell_fun = object@matrix_param$cell_fun    layer_fun = object@matrix_param$layer_fun    if (!is.null(cell_fun)) {        use_raster = FALSE    }    if (identical(object@matrix_param$gp$type, "none")) {        use_raster = FALSE    }    if (use_raster) {        device_info = switch(raster_device, png = c("grDevices",             "png", "readPNG"), jpeg = c("grDevices", "jpeg",             "readJPEG"), tiff = c("grDevices", "tiff", "readTIFF"),             CairoPNG = c("Cairo", "png", "readPNG"), CairoJPEG = c("Cairo",                 "jpeg", "readJPEG"), CairoTIFF = c("Cairo", "tiff",                 "readTIFF"), agg_png = c("ragg", "png", "readPNG"))        if (!requireNamespace(device_info[1])) {            stop_wrap(paste0("Need ", device_info[1], " package to write image."))        }        if (!requireNamespace(device_info[2])) {            stop_wrap(paste0("Need ", device_info[2], " package to read image."))        }        if (raster_device %in% c("png", "jpeg", "tiff")) {            if (!"type" %in% names(raster_device_param)) {                if (capabilities("cairo")) {                  raster_device_param$type = "cairo"                }            }        }        heatmap_width_pt = max(1, ceiling(convertWidth(unit(1,             "npc"), "bigpts", valueOnly = TRUE)))        heatmap_height_pt = max(1, ceiling(convertHeight(unit(1,             "npc"), "bigpts", valueOnly = TRUE)))        if (raster_quality < 1)             raster_quality = 1        heatmap_width_pt = ceiling(heatmap_width_pt * raster_quality)        heatmap_height_pt = ceiling(heatmap_height_pt * raster_quality)        matrix_is_resized = FALSE        raster_resize_mat = object@heatmap_param$raster_resize_mat        if (!identical(raster_resize_mat, FALSE)) {            if (is.logical(raster_resize_mat)) {                raster_resize_mat_fun = function(x) mean(x, na.rm = TRUE)            }            else {                if (!inherits(raster_resize_mat, "function")) {                  stop_wrap("`raster_resize_mat` should be set as logical scalar or a function.")                }                raster_resize_mat_fun = raster_resize_mat            }            if (heatmap_width_pt < nc && heatmap_height_pt <                 nr) {                mat2 = resize_matrix(mat, nr = heatmap_height_pt,                   nc = heatmap_width_pt, fun = raster_resize_mat_fun)                matrix_is_resized = TRUE            }            else if (heatmap_width_pt < nc) {                mat2 = resize_matrix(mat, nr = nr, nc = heatmap_width_pt,                   fun = raster_resize_mat_fun)                matrix_is_resized = TRUE            }            else if (heatmap_height_pt < nr) {                mat2 = resize_matrix(mat, nr = heatmap_height_pt,                   nc = nc, fun = raster_resize_mat_fun)                matrix_is_resized = TRUE            }        }        if (matrix_is_resized) {            raster_by_magick = FALSE        }        temp_dir = tempdir()        temp_image = tempfile(pattern = paste0(".heatmap_body_",             digest::digest(object@name), "_", kr, "_", kc), tmpdir = temp_dir,             fileext = paste0(".", device_info[2]))        device_fun = getFromNamespace(raster_device, ns = device_info[1])        if (raster_by_magick) {            temp_image_width = ceiling(max(heatmap_width_pt,                 nc, 1))            temp_image_height = ceiling(max(heatmap_height_pt,                 nr, 1))        }        else if (matrix_is_resized) {            temp_image_width = ceiling(max(heatmap_width_pt,                 1))            temp_image_height = ceiling(max(heatmap_height_pt,                 1))        }        else {            temp_image_width = ceiling(max(heatmap_width_pt,                 1))            temp_image_height = ceiling(max(heatmap_height_pt,                 1))        }        temp_image_width = as.integer(temp_image_width)        temp_image_height = as.integer(temp_image_height)        if (!is.na(ht_opt$raster_temp_image_max_width)) {            temp_image_width = min(temp_image_width, ht_opt$raster_temp_image_max_width)        }        if (!is.na(ht_opt$raster_temp_image_max_height)) {            temp_image_height = min(temp_image_height, ht_opt$raster_temp_image_max_height)        }        oe = try(do.call(device_fun, c(list(filename = temp_image,             width = temp_image_width, height = temp_image_height),             raster_device_param)))        if (inherits(oe, "try-error")) {            stop_wrap(qq("The size of the temporary image for rasterization is too huge (@{temp_image_width} x @{temp_image_height} px) that it is cannot be handled by the device function `@{device_info[1]}:@{raster_device}()`. Please reduce the maximal size of temporary image by setting proper values for `ht_opt$raster_temp_image_max_width` and `ht_opt$raster_temp_image_max_height`."))        }        if (object@heatmap_param$verbose) {            qqcat("saving into a temp image (.@{device_info[2]}) with size @{temp_image_width}x@{temp_image_height}px.\n")        }        if (matrix_is_resized) {            if (object@heatmap_param$verbose) {                qqcat("resize the matrix from (@{nrow(mat)}x@{ncol(mat)}) to (@{nrow(mat2)}x@{ncol(mat2)}).\n")            }            col_matrix2 = map_to_colors(object@matrix_color_mapping,                 mat2)            nc2 = ncol(mat2)            nr2 = nrow(mat2)            x2 = (seq_len(nc2) - 0.5)/nc2            y2 = (rev(seq_len(nr2)) - 0.5)/nr2            expand_index2 = expand.grid(seq_len(nr2), seq_len(nc2))            grid.rect(x2[expand_index2[[2]]], y2[expand_index2[[1]]],                 width = unit(1/nc2, "npc"), height = unit(1/nr2,                   "npc"), gp = do.call("gpar", c(list(fill = col_matrix2),                   gp)))        }        else {            grid.rect(x[expand_index[[2]]], y[expand_index[[1]]],                 width = unit(1/nc, "npc"), height = unit(1/nr,                   "npc"), gp = do.call("gpar", c(list(fill = col_matrix),                   gp)))        }        if (is.function(layer_fun)) {            if (length(as.list(formals(layer_fun))) == 7) {                layer_fun(column_order[expand_index[[2]]], row_order[expand_index[[1]]],                   unit(x[expand_index[[2]]], "npc"), unit(y[expand_index[[1]]],                     "npc"), unit(rep(1/nc, nrow(expand_index)),                     "npc"), unit(rep(1/nr, nrow(expand_index)),                     "npc"), as.vector(col_matrix))            }            else {                layer_fun(column_order[expand_index[[2]]], row_order[expand_index[[1]]],                   unit(x[expand_index[[2]]], "npc"), unit(y[expand_index[[1]]],                     "npc"), unit(rep(1/nc, nrow(expand_index)),                     "npc"), unit(rep(1/nr, nrow(expand_index)),                     "npc"), as.vector(col_matrix), kr, kc)            }        }        dev.off2()        if (object@heatmap_param$verbose) {            qqcat("resize the temp image to a size @{heatmap_width_pt}x@{heatmap_height_pt}px.\n")        }        if (raster_by_magick) {            if (object@heatmap_param$verbose) {                qqcat("image is read by magick.\n")            }            if (!requireNamespace("magick")) {                stop_wrap("'magick' package should be installed.")            }            image = magick::image_read(temp_image)            image = magick::image_resize(image, paste0(heatmap_width_pt,                 "x", heatmap_height_pt, "!"), filter = raster_magick_filter)            image = as.raster(image)        }        else {            if (object@heatmap_param$verbose) {                qqcat("image is read by @{device_info[2]}::@{device_info[3]}\n")            }            image = getFromNamespace(device_info[3], ns = device_info[2])(temp_image)        }        grid.raster(image, width = unit(1, "npc"), height = unit(1,             "npc"), interpolate = FALSE)        if (ht_opt("__export_image_size__")) {            if (inherits(image, "magick-image")) {                image = as.raster(image)            }            else {                tf = tempfile()                png(tf, width = heatmap_width_pt, height = heatmap_height_pt)                grid.raster(image, width = unit(1, "npc"), height = unit(1,                   "npc"))                dev.off()                image = as.raster(png::readPNG(tf))                file.remove(tf)            }            attr(image, "width") = heatmap_width_pt            attr(image, "height") = heatmap_height_pt        }        file.remove(temp_image)    }    else {        if (any(names(gp) %in% c("type"))) {            if (gp$type == "none") {            }            else {                grid.rect(x[expand_index[[2]]], y[expand_index[[1]]],                   width = unit(1/nc, "npc"), height = unit(1/nr,                     "npc"), gp = do.call("gpar", c(list(fill = col_matrix),                     gp)))            }        }        else {            grid.rect(x[expand_index[[2]]], y[expand_index[[1]]],                 width = unit(1/nc, "npc"), height = unit(1/nr,                   "npc"), gp = do.call("gpar", c(list(fill = col_matrix),                   gp)))        }        if (is.function(cell_fun)) {            for (i in seq_len(nr)) {                for (j in seq_len(nc)) {                  cell_fun(column_order[j], row_order[i], unit(x[j],                     "npc"), unit(y[i], "npc"), unit(1/nc, "npc"),                     unit(1/nr, "npc"), col_matrix[i, j])                }            }        }        if (is.function(layer_fun)) {            if (length(as.list(formals(layer_fun))) == 7) {                layer_fun(column_order[expand_index[[2]]], row_order[expand_index[[1]]],                   unit(x[expand_index[[2]]], "npc"), unit(y[expand_index[[1]]],                     "npc"), unit(rep(1/nc, nrow(expand_index)),                     "npc"), unit(rep(1/nr, nrow(expand_index)),                     "npc"), as.vector(col_matrix))            }            else {                layer_fun(column_order[expand_index[[2]]], row_order[expand_index[[1]]],                   unit(x[expand_index[[2]]], "npc"), unit(y[expand_index[[1]]],                     "npc"), unit(rep(1/nc, nrow(expand_index)),                     "npc"), unit(rep(1/nr, nrow(expand_index)),                     "npc"), as.vector(col_matrix), kr, kc)            }        }    }    if (!(identical(border, FALSE) || identical(border, NA))) {        border_gp = object@matrix_param$border_gp        if (!identical(border, TRUE)) {            border_gp$col = border        }        if ("fill" %in% names(border_gp)) {            message_wrap("`fill` is ignored in `border_gp`. The value for `fill` is always 'transparent'.")        }        border_gp$fill = "transparent"        grid.rect(gp = border_gp)    }    upViewport()})
41: .local(object, ...)
42: draw_heatmap_body(object, kr = i, kc = j, x = slice_x[j], y = slice_y[i],     width = slice_width[j], height = slice_height[i], just = c("left",         "top"))
43: draw_heatmap_body(object, kr = i, kc = j, x = slice_x[j], y = slice_y[i],     width = slice_width[j], height = slice_height[i], just = c("left",         "top"))
44: ht_graphic_fun_list[[j]](object)
45: .local(object, ...)
46: draw(ht, internal = TRUE)
47: draw(ht, internal = TRUE)
48: .local(object, ...)
49: draw_heatmap_list(object)
50: draw_heatmap_list(object)
51: ht_graphic_fun_list[[j]](object)
52: eval(code)
53: eval(code)
54: .local(object, ...)
55: draw(ht_list, ...)
56: draw(ht_list, ...)
57: .local(object, ...)
58: draw(object)
59: draw(object)
60: (new("standardGeneric", .Data = function (object) standardGeneric("show"), generic = "show", package = "methods",     group = list(), valueClass = character(0), signature = "object",     default = new("derivedDefaultMethod", .Data = function (object)     showDefault(object), target = new("signature", .Data = "ANY",         names = "object", package = "methods"), defined = new("signature",         .Data = "ANY", names = "object", package = "methods"),         generic = "show"), skeleton = (new("derivedDefaultMethod",         .Data = function (object)         showDefault(object), target = new("signature", .Data = "ANY",             names = "object", package = "methods"), defined = new("signature",             .Data = "ANY", names = "object", package = "methods"),         generic = "show"))(object)))(new("Heatmap", name = "Cor",     matrix = c(0.909324005473489, 0.132567145056242, -0.26812938106167,     -0.545656476613206, -0.541326440061936, -0.0313603344454657,     -0.024815451015962, 0.155854932013126, 0.841837149022825,     0.189804592370376, -0.292759990730551, -0.0634808481242012,     -0.469114930394571, -0.419564214314375, -0.0101716716374809,     0.831751573833378, 0.74881531112361, -0.0255098657671484,     -0.230600365048219, -0.658893562723194, -0.653393375143041,     -0.352144775836744, 0.115562033047779, 0.808806821591698,     0.575802400826772, -0.112405262942997, -0.420832961573367,     -0.457481149450513, -0.508610549717773, -0.284214073076683,     0.230975016807478, 0.900959236336823, 0.343363601534913,     -0.222592577885192, -0.127067904959661, -0.434085370023283,     -0.345611830324081, -0.350131745075143, 0.177168470948182,     0.870305410849732, 0.144271116634794, 0.280656085429145,     0.0866006296911782, -0.703168222171207, -0.730468970295095,     -0.440535141219609, -0.16357202679916, 0.945689879685262,     0.785766833620213), matrix_param = list(row_km = 1, row_km_repeats = 1,         row_gap = 1, column_km = 1, column_km_repeats = 1, column_gap = 1,         jitter = FALSE, gp = list(col = "black", lwd = 1, lineheight = 0.9),         border = NA, border_gp = list(col = "black"), cell_fun = function (j,             i, x, y, width, height, fill)         {            grid.text(anno_matrix_subset[i, j], x, y, gp = gpar(fontsize = 10))        }, width = 7, height = 7), matrix_color_mapping = new("ColorMapping",         colors = c("#762A83FF", "#A47BB7FF", "#F0E9F1FF", "#B4DCAFFF",         "#1B7837FF"), levels = c(-1, -0.5, 0, 0.5, 1), col_fun = function (x = NULL,             return_rgb = FALSE, max_value = 1)         {            if (is.null(x)) {                stop_wrap("Please specify `x`\n")            }            att = attributes(x)            if (is.data.frame(x))                 x = as.matrix(x)            l_na = is.na(x)            if (all(l_na)) {                return(rep(NA, length(l_na)))            }            x2 = x[!l_na]            x2 = ifelse(x2 < breaks[1], breaks[1], ifelse(x2 >                 breaks[length(breaks)], breaks[length(breaks)],                 x2))            ibin = .bincode(x2, breaks, right = TRUE, include.lowest = TRUE)            res_col = character(length(x2))            for (i in unique(ibin)) {                l = ibin == i                res_col[l] = .get_color(x2[l], breaks[i], breaks[i +                   1], colors[i, ], colors[i + 1, ], space = space)            }            res_col = paste(res_col, transparency_str[1], sep = "")            if (return_rgb) {                res_col = t(col2rgb(as.vector(res_col), alpha = TRUE)/255)                return(res_col)            }            else {                res_col2 = character(length(x))                res_col2[l_na] = NA                res_col2[!l_na] = res_col                attributes(res_col2) = att                return(res_col2)            }        }, type = "continuous", name = "Cor", na_col = "#BEBEBEFF",         full_col = character(0)), matrix_legend_param = list(        title = "Cor"), row_title = character(0), row_title_param = list(        rot = 90, side = "left", gp = list(fontsize = 13.2, lineheight = 0.9),         just = c(0.5, 0)), column_title = character(0), column_title_param = list(        rot = 0, side = "top", gp = list(fontsize = 13.2, lineheight = 0.9),         just = c(0.5, 0)), row_dend_list = list(), row_dend_slice = NULL,     row_dend_param = list(cluster = FALSE, distance = "euclidean",         method = "complete", side = "left", width = 0.5, show = FALSE,         gp = list(lineheight = 0.9), reorder = TRUE, cluster_slices = TRUE),     row_order_list = list(), row_order = 1:7, column_dend_list = list(),     column_dend_slice = NULL, column_dend_param = list(cluster = FALSE,         distance = "euclidean", method = "complete", side = "top",         height = 0.5, show = FALSE, gp = list(lineheight = 0.9),         reorder = TRUE, cluster_slices = TRUE), column_order_list = list(),     column_order = 1:7, row_names_param = list(labels = c("Sp07D01 ~ L1",     "Sp07D02 ~ L2/3", "Sp07D03 ~ L3/4", "Sp07D04 ~ L5", "Sp07D06 ~ L6",     "Sp07D05 ~ WM", "Sp07D07 ~ WM"), side = "right", show = TRUE,         gp = list(fontsize = 12, lineheight = 0.9), rot = 0,         centered = FALSE, max_width = list(list(1, list(list(            6, NULL, 1L), list(2, NULL, 7L)), 201L)), anno = new("AnnotationFunction",             which = "row", fun_name = "anno_text", width = 30.7128333333333,             height = 1, n = 7L, var_env = <environment>, fun = function (index,                 k = 1, n = 1)             {                n = length(index)                gp = subset_gp(gp, index)                gp2 = gp                if ("border" %in% names(gp2))                   gp2$col = gp2$border                if ("fill" %in% names(gp2)) {                  if (!"border" %in% names(gp2))                     gp2$col = gp2$fill                }                if (any(c("border", "fill") %in% names(gp2))) {                  grid.rect(y = (n - seq_along(index) + 0.5)/n,                     height = 1/n, gp = gp2)                }                grid.text(value[index], location, (n - seq_along(index) +                   0.5)/n, gp = gp, just = just, rot = rot)            }, subset_rule = list(value = function (x, i)             x[i], gp = function (gp, i)             {                gp = lapply(gp, function(x) {                  if (length(x) == 1)                     x                  else x[i]                })                class(gp) = "gpar"                return(gp)            }), subsettable = TRUE, data_scale = c(0, 1), extended = c(0,             0, 0, 0), show_name = FALSE)), column_names_param = list(        labels = c("Layer1", "Layer2", "Layer3", "Layer4", "Layer5",         "Layer6", "WM"), side = "bottom", show = TRUE, gp = list(            fontsize = 12, lineheight = 0.9), rot = 90, centered = FALSE,         max_height = list(list(1, list(list(6, NULL, 1L), list(            2, NULL, 7L)), 201L)), anno = new("AnnotationFunction",             which = "column", fun_name = "anno_text", width = 1,             height = 12.7296333333333, n = 7L, var_env = <environment>,             fun = function (index, k = NULL, N = NULL, vp_name = NULL)             {                n = length(index)                gp = subset_gp(gp, index)                gp2 = gp                if ("border" %in% names(gp2))                   gp2$col = gp2$border                if ("fill" %in% names(gp2)) {                  if (!"border" %in% names(gp2))                     gp2$col = gp2$fill                }                if (any(c("border", "fill") %in% names(gp2))) {                  grid.rect(x = (seq_along(index) - 0.5)/n, width = 1/n,                     gp = gp2)                }                grid.text(value[index], (seq_along(index) - 0.5)/n,                   location, gp = gp, just = just, rot = rot)            }, subset_rule = list(value = function (x, i)             x[i], gp = function (gp, i)             {                gp = lapply(gp, function(x) {                  if (length(x) == 1)                     x                  else x[i]                })                class(gp) = "gpar"                return(gp)            }), subsettable = TRUE, data_scale = c(0, 1), extended = c(0,             0, 0, 0), show_name = FALSE)), top_annotation = NULL,     top_annotation_param = list(height = 0), bottom_annotation = new("HeatmapAnnotation",         name = "heatmap_annotation_0", anno_list = list(` ` = new("SingleAnnotation",             name = " ", label = " ", color_mapping = new("ColorMapping",                 colors = c(Layer1 = "#F0027FFF", Layer2 = "#377EB8FF",                 Layer3 = "#4DAF4AFF", Layer4 = "#984EA3FF", Layer5 = "#FFD700FF",                 Layer6 = "#FF7F00FF", WM = "#1A1A1AFF"), levels = c("Layer1",                 "Layer2", "Layer3", "Layer4", "Layer5", "Layer6",                 "WM"), col_fun = function ()                 NULL, type = "discrete", name = " ", na_col = "#BEBEBEFF",                 full_col = c(Layer1 = "#F0027FFF", Layer2 = "#377EB8FF",                 Layer3 = "#4DAF4AFF", Layer4 = "#984EA3FF", Layer5 = "#FFD700FF",                 Layer6 = "#FF7F00FF", WM = "#1A1A1AFF", `NA` = "#FFFFFF00",                 WM2 = "#666666FF")), legend_param = list(), fun = new("AnnotationFunction",                 which = "column", fun_name = "anno_simple", width = 1,                 height = 5, n = 7L, var_env = <environment>,                 fun = function (index, k = 1, n = 1)                 {                  n = length(index)                  x = (seq_len(n) - 0.5)/n                  if (is.matrix(value)) {                    nc = ncol(value)                    pch = pch[index, , drop = FALSE]                    for (i in seq_len(nc)) {                      if (color_mapping@type == "continuous" ||                         !is.null(gp$col)) {                        fill = map_to_colors(color_mapping, value[index,                           i])                        flag = 0                        if (is.null(gp$col)) {                          gp$col = fill                          flag = 1                        }                        grid.rect(x, y = (nc - i + 0.5)/nc, width = 1/n,                           height = 1/nc, gp = do.call("gpar",                             c(list(fill = fill), gp)))                        if (flag)                           gp$col = NULL                      }                      else {                        r = rle(value[index, i])                        fill = map_to_colors(color_mapping, r$values)                        if (is.null(gp$col))                           gp$col = fill                        grid.rect(cumsum(r$lengths)/n, y = (nc -                           i + 0.5)/nc, width = r$length/n, height = 1/nc,                           just = "right", gp = do.call("gpar",                             c(list(fill = fill), gp)))                      }                      if (!is.null(pch)) {                        l = !is.na(pch[, i])                        if (any(l)) {                          if (is.character(pch)) {                            text_gp = subset_gp(pt_gp, i)                            text_gp$fontsize = convertHeight({                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, "pt", valueOnly = TRUE)                            grid.text(pch[l, i], x = x[l], y = rep((nc -                               i + 0.5)/nc, sum(l)), gp = text_gp)                          }                          else {                            grid.points(x[l], y = rep((nc - i +                               0.5)/nc, sum(l)), pch = pch[l,                               i], size = {                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, gp = subset_gp(pt_gp, i))                          }                        }                      }                    }                  }                  else {                    if (color_mapping@type == "continuous" ||                       !is.null(gp$col)) {                      fill = map_to_colors(color_mapping, value[index])                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(x, y = 0.5, width = 1/n, height = 1,                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    else {                      r = rle(value[index])                      fill = map_to_colors(color_mapping, r$values)                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(cumsum(r$lengths)/n, y = 0.5,                         width = r$length/n, height = 1, just = "right",                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    if (!is.null(pch)) {                      pch = pch[index]                      pt_size = pt_size[index]                      pt_gp = subset_gp(pt_gp, index)                      l = !is.na(pch)                      if (any(l)) {                        if (is.character(pch)) {                          text_gp = subset_gp(pt_gp, which(l))                          text_gp$fontsize = convertHeight(pt_size[l],                             "pt", valueOnly = TRUE)                          grid.text(pch[l], x = x[l], y = rep(0.5,                             sum(l)), gp = text_gp)                        }                        else {                          grid.points(x[l], y = rep(0.5, sum(l)),                             pch = pch[l], size = pt_size[l],                             gp = subset_gp(pt_gp, which(l)))                        }                      }                    }                  }                  if (border)                     grid.rect(gp = gpar(fill = "transparent"))                }, subset_rule = list(value = function (x, i)                 x[i]), subsettable = TRUE, data_scale = c(0.5,                 1.5), extended = c(0, 0, 0, 0), show_name = TRUE),             show_legend = FALSE, which = "column", name_to_data_vp = FALSE,             name_param = list(show = TRUE, label = " ", x = list(                list(1, list(list(1, NULL, 0L), list(1, NULL,                   7L)), 201L)), y = 0.5, offset = 1, just = "left",                 gp = list(lineheight = 0.9), rot = 0, side = "right"),             is_anno_matrix = FALSE, color_is_random = FALSE,             width = 1, height = 5, extended = c(0, 0, 0, 2.17686666666666            ), subsettable = TRUE)), anno_size = 5, which = "column",         width = 1, height = 5, gap = 1, subsettable = TRUE, extended = c(0,         0, 0, 2.17686666666666), param = list(simple_anno_size = 5,             simple_anno_size_adjust = FALSE, is_height_set = FALSE,             is_width_set = FALSE, is_annotation_height_set = FALSE,             is_annotation_width_set = FALSE)), bottom_annotation_param = list(        height = 6), left_annotation = NULL, left_annotation_param = list(        width = 0), right_annotation = new("HeatmapAnnotation",         name = "heatmap_annotation_2", anno_list = list(domain_color = new("SingleAnnotation",             name = "domain_color", label = "domain_color", color_mapping = new("ColorMapping",                 colors = c(`1` = "#5A5156FF", `2` = "#E4E1E3FF",                 `3` = "#F6222EFF", `4` = "#FE00FAFF", `5` = "#16FF32FF",                 `6` = "#3283FEFF", `7` = "#FEAF16FF"), levels = c("1",                 "2", "3", "4", "5", "6", "7"), col_fun = function ()                 NULL, type = "discrete", name = "domain_color",                 na_col = "#BEBEBEFF", full_col = c(`1` = "#5A5156FF",                 `2` = "#E4E1E3FF", `3` = "#F6222EFF", `4` = "#FE00FAFF",                 `5` = "#16FF32FF", `6` = "#3283FEFF", `7` = "#FEAF16FF",                 `8` = "#B00068FF", `9` = "#1CFFCEFF", `10` = "#90AD1CFF",                 `11` = "#2ED9FFFF", `12` = "#DEA0FDFF", `13` = "#AA0DFEFF",                 `14` = "#F8A19FFF", `15` = "#325A9BFF", `16` = "#C4451CFF",                 `17` = "#1C8356FF", `18` = "#85660DFF", `19` = "#B10DA1FF",                 `20` = "#FBE426FF", `21` = "#1CBE4FFF", `22` = "#FA0087FF",                 `23` = "#FC1CBFFF", `24` = "#F7E1A0FF", `25` = "#C075A6FF",                 `26` = "#782AB6FF", `27` = "#AAF400FF", `28` = "#BDCDFFFF"                )), legend_param = list(), fun = new("AnnotationFunction",                 which = "row", fun_name = "anno_simple", width = 5,                 height = 1, n = 7L, var_env = <environment>,                 fun = function (index, k = 1, n = 1)                 {                  n = length(index)                  y = (n - seq_len(n) + 0.5)/n                  if (is.matrix(value)) {                    nc = ncol(value)                    pch = pch[index, , drop = FALSE]                    for (i in seq_len(nc)) {                      if (color_mapping@type == "continuous" ||                         !is.null(gp$col)) {                        fill = map_to_colors(color_mapping, value[index,                           i])                        flag = 0                        if (is.null(gp$col)) {                          gp$col = fill                          flag = 1                        }                        grid.rect(x = (i - 0.5)/nc, y, height = 1/n,                           width = 1/nc, gp = do.call("gpar",                             c(list(fill = fill), gp)))                        if (flag)                           gp$col = NULL                      }                      else {                        r = rle(value[index, i])                        fill = map_to_colors(color_mapping, r$values)                        if (is.null(gp$col))                           gp$col = fill                        grid.rect(x = (i - 0.5)/nc, y = 1 - cumsum(r$lengths)/n,                           height = r$length/n, width = 1/nc,                           just = "bottom", gp = do.call("gpar",                             c(list(fill = fill), gp)))                      }                      if (!is.null(pch)) {                        l = !is.na(pch[, i])                        if (any(l)) {                          if (is.character(pch)) {                            text_gp = subset_gp(pt_gp, i)                            text_gp$fontsize = convertHeight({                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, "pt", valueOnly = TRUE)                            grid.text(pch[l, i], x = rep((i -                               0.5)/nc, sum(l)), y = y[l], gp = text_gp)                          }                          else {                            grid.points(x = rep((i - 0.5)/nc,                               sum(l)), y = y[l], pch = pch[l,                               i], size = {                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, gp = subset_gp(pt_gp, i))                          }                        }                      }                    }                  }                  else {                    if (color_mapping@type == "continuous" ||                       !is.null(gp$col)) {                      fill = map_to_colors(color_mapping, value[index])                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(x = 0.5, y, height = 1/n, width = 1,                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    else {                      r = rle(value[index])                      fill = map_to_colors(color_mapping, r$values)                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(x = 0.5, y = 1 - cumsum(r$lengths)/n,                         height = r$length/n, width = 1, just = "bottom",                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    if (!is.null(pch)) {                      pch = pch[index]                      pt_size = pt_size[index]                      pt_gp = subset_gp(pt_gp, index)                      l = !is.na(pch)                      if (any(l)) {                        if (is.character(pch)) {                          text_gp = subset_gp(pt_gp, which(l))                          text_gp$fontsize = convertHeight(pt_size[l],                             "pt", valueOnly = TRUE)                          grid.text(pch[l], x = rep(0.5, sum(l)),                             y = y[l], gp = text_gp)                        }                        else {                          grid.points(x = rep(0.5, sum(l)), y = y[l],                             pch = pch[l], size = pt_size[l],                             gp = subset_gp(pt_gp, which(l)))                        }                      }                    }                  }                  if (border)                     grid.rect(gp = gpar(fill = "transparent"))                }, subset_rule = list(value = function (x, i)                 x[i]), subsettable = TRUE, data_scale = c(0.5,                 1.5), extended = c(0, 0, 0, 0), show_name = TRUE),             show_legend = FALSE, which = "row", name_to_data_vp = FALSE,             name_param = list(show = TRUE, label = "domain_color",                 x = 0.5, y = list(list(1, list(list(0, NULL,                   0L), list(-1, NULL, 7L)), 201L)), offset = 1,                 just = "right", gp = list(lineheight = 0.9),                 rot = 90, side = "bottom"), is_anno_matrix = FALSE,             color_is_random = FALSE, width = 5, height = 1, extended = c(26.4084666666667,             0, 0, 0), subsettable = TRUE), layer_anno = new("SingleAnnotation",             name = "layer_anno", label = "layer_anno", color_mapping = new("ColorMapping",                 colors = c(L1 = "#F0027FFF", `L2/3` = "#50DDACFF",                 `L3/4` = "#8278B0FF", L5 = "#FFD700FF", L6 = "#FF7F00FF",                 WM = "#1A1A1AFF"), levels = c("L1", "L2/3", "L3/4",                 "L5", "L6", "WM"), col_fun = function ()                 NULL, type = "discrete", name = "layer_anno",                 na_col = "#BEBEBEFF", full_col = c(L1 = "#F0027FFF",                 L2 = "#377EB8FF", L3 = "#4DAF4AFF", L4 = "#984EA3FF",                 L5 = "#FFD700FF", L6 = "#FF7F00FF", WM = "#1A1A1AFF",                 `NA` = "#FFFFFF00", WM2 = "#666666FF", `L1/2` = "#BF3889FF",                 `L2/3` = "#50DDACFF", `L3/4` = "#8278B0FF", `L4/5` = "#BD8339FF",                 `L5/6` = "#FFB300FF", `L6/WM` = "#7A3D00FF")),             legend_param = list(), fun = new("AnnotationFunction",                 which = "row", fun_name = "anno_simple", width = 5,                 height = 1, n = 7L, var_env = <environment>,                 fun = function (index, k = 1, n = 1)                 {                  n = length(index)                  y = (n - seq_len(n) + 0.5)/n                  if (is.matrix(value)) {                    nc = ncol(value)                    pch = pch[index, , drop = FALSE]                    for (i in seq_len(nc)) {                      if (color_mapping@type == "continuous" ||                         !is.null(gp$col)) {                        fill = map_to_colors(color_mapping, value[index,                           i])                        flag = 0                        if (is.null(gp$col)) {                          gp$col = fill                          flag = 1                        }                        grid.rect(x = (i - 0.5)/nc, y, height = 1/n,                           width = 1/nc, gp = do.call("gpar",                             c(list(fill = fill), gp)))                        if (flag)                           gp$col = NULL                      }                      else {                        r = rle(value[index, i])                        fill = map_to_colors(color_mapping, r$values)                        if (is.null(gp$col))                           gp$col = fill                        grid.rect(x = (i - 0.5)/nc, y = 1 - cumsum(r$lengths)/n,                           height = r$length/n, width = 1/nc,                           just = "bottom", gp = do.call("gpar",                             c(list(fill = fill), gp)))                      }                      if (!is.null(pch)) {                        l = !is.na(pch[, i])                        if (any(l)) {                          if (is.character(pch)) {                            text_gp = subset_gp(pt_gp, i)                            text_gp$fontsize = convertHeight({                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, "pt", valueOnly = TRUE)                            grid.text(pch[l, i], x = rep((i -                               0.5)/nc, sum(l)), y = y[l], gp = text_gp)                          }                          else {                            grid.points(x = rep((i - 0.5)/nc,                               sum(l)), y = y[l], pch = pch[l,                               i], size = {                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, gp = subset_gp(pt_gp, i))                          }                        }                      }                    }                  }                  else {                    if (color_mapping@type == "continuous" ||                       !is.null(gp$col)) {                      fill = map_to_colors(color_mapping, value[index])                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(x = 0.5, y, height = 1/n, width = 1,                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    else {                      r = rle(value[index])                      fill = map_to_colors(color_mapping, r$values)                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(x = 0.5, y = 1 - cumsum(r$lengths)/n,                         height = r$length/n, width = 1, just = "bottom",                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    if (!is.null(pch)) {                      pch = pch[index]                      pt_size = pt_size[index]                      pt_gp = subset_gp(pt_gp, index)                      l = !is.na(pch)                      if (any(l)) {                        if (is.character(pch)) {                          text_gp = subset_gp(pt_gp, which(l))                          text_gp$fontsize = convertHeight(pt_size[l],                             "pt", valueOnly = TRUE)                          grid.text(pch[l], x = rep(0.5, sum(l)),                             y = y[l], gp = text_gp)                        }                        else {                          grid.points(x = rep(0.5, sum(l)), y = y[l],                             pch = pch[l], size = pt_size[l],                             gp = subset_gp(pt_gp, which(l)))                        }                      }                    }                  }                  if (border)                     grid.rect(gp = gpar(fill = "transparent"))                }, subset_rule = list(value = function (x, i)                 x[i]), subsettable = TRUE, data_scale = c(0.5,                 1.5), extended = c(0, 0, 0, 0), show_name = TRUE),             show_legend = FALSE, which = "row", name_to_data_vp = FALSE,             name_param = list(show = TRUE, label = "layer_anno",                 x = 0.5, y = list(list(1, list(list(0, NULL,                   0L), list(-1, NULL, 7L)), 201L)), offset = 1,                 just = "right", gp = list(lineheight = 0.9),                 rot = 90, side = "bottom"), is_anno_matrix = FALSE,             color_is_random = FALSE, width = 5, height = 1, extended = c(21.7306333333333,             0, 0, 0), subsettable = TRUE)), anno_size = c(5,         5), which = "row", width = 10.3514598035146, height = 1,         gap = c(1, 1), subsettable = TRUE, extended = c(26.4084666666667,         0, 0, 0), param = list(simple_anno_size = 5, simple_anno_size_adjust = FALSE,             is_height_set = FALSE, is_width_set = FALSE, is_annotation_height_set = FALSE,             is_annotation_width_set = FALSE)), right_annotation_param = list(        width = 11.3514598035146), heatmap_param = list(width = 1,         height = 1, show_heatmap_legend = TRUE, use_raster = FALSE,         raster_device = "CairoPNG", raster_quality = 1, raster_device_param = list(),         raster_resize_mat = FALSE, raster_by_magick = TRUE, verbose = FALSE,         calling_env = <environment>, show_parent_dend_line = TRUE),     layout = list(layout_size = list(column_title_top_height = 0,         column_dend_top_height = 0, column_anno_top_height = 0,         column_names_top_height = 0, column_title_bottom_height = 0,         column_dend_bottom_height = 0, column_anno_bottom_height = 0,         column_names_bottom_height = 0, row_title_left_width = 0,         row_dend_left_width = 0, row_names_left_width = 0, row_dend_right_width = 0,         row_names_right_width = 0, row_title_right_width = 0,         row_anno_left_width = 0, row_anno_right_width = 0), layout_index = logical(0),         graphic_fun_list = list(), initialized = FALSE)))
61: (new("standardGeneric", .Data = function (object) standardGeneric("show"), generic = "show", package = "methods",     group = list(), valueClass = character(0), signature = "object",     default = new("derivedDefaultMethod", .Data = function (object)     showDefault(object), target = new("signature", .Data = "ANY",         names = "object", package = "methods"), defined = new("signature",         .Data = "ANY", names = "object", package = "methods"),         generic = "show"), skeleton = (new("derivedDefaultMethod",         .Data = function (object)         showDefault(object), target = new("signature", .Data = "ANY",             names = "object", package = "methods"), defined = new("signature",             .Data = "ANY", names = "object", package = "methods"),         generic = "show"))(object)))(new("Heatmap", name = "Cor",     matrix = c(0.909324005473489, 0.132567145056242, -0.26812938106167,     -0.545656476613206, -0.541326440061936, -0.0313603344454657,     -0.024815451015962, 0.155854932013126, 0.841837149022825,     0.189804592370376, -0.292759990730551, -0.0634808481242012,     -0.469114930394571, -0.419564214314375, -0.0101716716374809,     0.831751573833378, 0.74881531112361, -0.0255098657671484,     -0.230600365048219, -0.658893562723194, -0.653393375143041,     -0.352144775836744, 0.115562033047779, 0.808806821591698,     0.575802400826772, -0.112405262942997, -0.420832961573367,     -0.457481149450513, -0.508610549717773, -0.284214073076683,     0.230975016807478, 0.900959236336823, 0.343363601534913,     -0.222592577885192, -0.127067904959661, -0.434085370023283,     -0.345611830324081, -0.350131745075143, 0.177168470948182,     0.870305410849732, 0.144271116634794, 0.280656085429145,     0.0866006296911782, -0.703168222171207, -0.730468970295095,     -0.440535141219609, -0.16357202679916, 0.945689879685262,     0.785766833620213), matrix_param = list(row_km = 1, row_km_repeats = 1,         row_gap = 1, column_km = 1, column_km_repeats = 1, column_gap = 1,         jitter = FALSE, gp = list(col = "black", lwd = 1, lineheight = 0.9),         border = NA, border_gp = list(col = "black"), cell_fun = function (j,             i, x, y, width, height, fill)         {            grid.text(anno_matrix_subset[i, j], x, y, gp = gpar(fontsize = 10))        }, width = 7, height = 7), matrix_color_mapping = new("ColorMapping",         colors = c("#762A83FF", "#A47BB7FF", "#F0E9F1FF", "#B4DCAFFF",         "#1B7837FF"), levels = c(-1, -0.5, 0, 0.5, 1), col_fun = function (x = NULL,             return_rgb = FALSE, max_value = 1)         {            if (is.null(x)) {                stop_wrap("Please specify `x`\n")            }            att = attributes(x)            if (is.data.frame(x))                 x = as.matrix(x)            l_na = is.na(x)            if (all(l_na)) {                return(rep(NA, length(l_na)))            }            x2 = x[!l_na]            x2 = ifelse(x2 < breaks[1], breaks[1], ifelse(x2 >                 breaks[length(breaks)], breaks[length(breaks)],                 x2))            ibin = .bincode(x2, breaks, right = TRUE, include.lowest = TRUE)            res_col = character(length(x2))            for (i in unique(ibin)) {                l = ibin == i                res_col[l] = .get_color(x2[l], breaks[i], breaks[i +                   1], colors[i, ], colors[i + 1, ], space = space)            }            res_col = paste(res_col, transparency_str[1], sep = "")            if (return_rgb) {                res_col = t(col2rgb(as.vector(res_col), alpha = TRUE)/255)                return(res_col)            }            else {                res_col2 = character(length(x))                res_col2[l_na] = NA                res_col2[!l_na] = res_col                attributes(res_col2) = att                return(res_col2)            }        }, type = "continuous", name = "Cor", na_col = "#BEBEBEFF",         full_col = character(0)), matrix_legend_param = list(        title = "Cor"), row_title = character(0), row_title_param = list(        rot = 90, side = "left", gp = list(fontsize = 13.2, lineheight = 0.9),         just = c(0.5, 0)), column_title = character(0), column_title_param = list(        rot = 0, side = "top", gp = list(fontsize = 13.2, lineheight = 0.9),         just = c(0.5, 0)), row_dend_list = list(), row_dend_slice = NULL,     row_dend_param = list(cluster = FALSE, distance = "euclidean",         method = "complete", side = "left", width = 0.5, show = FALSE,         gp = list(lineheight = 0.9), reorder = TRUE, cluster_slices = TRUE),     row_order_list = list(), row_order = 1:7, column_dend_list = list(),     column_dend_slice = NULL, column_dend_param = list(cluster = FALSE,         distance = "euclidean", method = "complete", side = "top",         height = 0.5, show = FALSE, gp = list(lineheight = 0.9),         reorder = TRUE, cluster_slices = TRUE), column_order_list = list(),     column_order = 1:7, row_names_param = list(labels = c("Sp07D01 ~ L1",     "Sp07D02 ~ L2/3", "Sp07D03 ~ L3/4", "Sp07D04 ~ L5", "Sp07D06 ~ L6",     "Sp07D05 ~ WM", "Sp07D07 ~ WM"), side = "right", show = TRUE,         gp = list(fontsize = 12, lineheight = 0.9), rot = 0,         centered = FALSE, max_width = list(list(1, list(list(            6, NULL, 1L), list(2, NULL, 7L)), 201L)), anno = new("AnnotationFunction",             which = "row", fun_name = "anno_text", width = 30.7128333333333,             height = 1, n = 7L, var_env = <environment>, fun = function (index,                 k = 1, n = 1)             {                n = length(index)                gp = subset_gp(gp, index)                gp2 = gp                if ("border" %in% names(gp2))                   gp2$col = gp2$border                if ("fill" %in% names(gp2)) {                  if (!"border" %in% names(gp2))                     gp2$col = gp2$fill                }                if (any(c("border", "fill") %in% names(gp2))) {                  grid.rect(y = (n - seq_along(index) + 0.5)/n,                     height = 1/n, gp = gp2)                }                grid.text(value[index], location, (n - seq_along(index) +                   0.5)/n, gp = gp, just = just, rot = rot)            }, subset_rule = list(value = function (x, i)             x[i], gp = function (gp, i)             {                gp = lapply(gp, function(x) {                  if (length(x) == 1)                     x                  else x[i]                })                class(gp) = "gpar"                return(gp)            }), subsettable = TRUE, data_scale = c(0, 1), extended = c(0,             0, 0, 0), show_name = FALSE)), column_names_param = list(        labels = c("Layer1", "Layer2", "Layer3", "Layer4", "Layer5",         "Layer6", "WM"), side = "bottom", show = TRUE, gp = list(            fontsize = 12, lineheight = 0.9), rot = 90, centered = FALSE,         max_height = list(list(1, list(list(6, NULL, 1L), list(            2, NULL, 7L)), 201L)), anno = new("AnnotationFunction",             which = "column", fun_name = "anno_text", width = 1,             height = 12.7296333333333, n = 7L, var_env = <environment>,             fun = function (index, k = NULL, N = NULL, vp_name = NULL)             {                n = length(index)                gp = subset_gp(gp, index)                gp2 = gp                if ("border" %in% names(gp2))                   gp2$col = gp2$border                if ("fill" %in% names(gp2)) {                  if (!"border" %in% names(gp2))                     gp2$col = gp2$fill                }                if (any(c("border", "fill") %in% names(gp2))) {                  grid.rect(x = (seq_along(index) - 0.5)/n, width = 1/n,                     gp = gp2)                }                grid.text(value[index], (seq_along(index) - 0.5)/n,                   location, gp = gp, just = just, rot = rot)            }, subset_rule = list(value = function (x, i)             x[i], gp = function (gp, i)             {                gp = lapply(gp, function(x) {                  if (length(x) == 1)                     x                  else x[i]                })                class(gp) = "gpar"                return(gp)            }), subsettable = TRUE, data_scale = c(0, 1), extended = c(0,             0, 0, 0), show_name = FALSE)), top_annotation = NULL,     top_annotation_param = list(height = 0), bottom_annotation = new("HeatmapAnnotation",         name = "heatmap_annotation_0", anno_list = list(` ` = new("SingleAnnotation",             name = " ", label = " ", color_mapping = new("ColorMapping",                 colors = c(Layer1 = "#F0027FFF", Layer2 = "#377EB8FF",                 Layer3 = "#4DAF4AFF", Layer4 = "#984EA3FF", Layer5 = "#FFD700FF",                 Layer6 = "#FF7F00FF", WM = "#1A1A1AFF"), levels = c("Layer1",                 "Layer2", "Layer3", "Layer4", "Layer5", "Layer6",                 "WM"), col_fun = function ()                 NULL, type = "discrete", name = " ", na_col = "#BEBEBEFF",                 full_col = c(Layer1 = "#F0027FFF", Layer2 = "#377EB8FF",                 Layer3 = "#4DAF4AFF", Layer4 = "#984EA3FF", Layer5 = "#FFD700FF",                 Layer6 = "#FF7F00FF", WM = "#1A1A1AFF", `NA` = "#FFFFFF00",                 WM2 = "#666666FF")), legend_param = list(), fun = new("AnnotationFunction",                 which = "column", fun_name = "anno_simple", width = 1,                 height = 5, n = 7L, var_env = <environment>,                 fun = function (index, k = 1, n = 1)                 {                  n = length(index)                  x = (seq_len(n) - 0.5)/n                  if (is.matrix(value)) {                    nc = ncol(value)                    pch = pch[index, , drop = FALSE]                    for (i in seq_len(nc)) {                      if (color_mapping@type == "continuous" ||                         !is.null(gp$col)) {                        fill = map_to_colors(color_mapping, value[index,                           i])                        flag = 0                        if (is.null(gp$col)) {                          gp$col = fill                          flag = 1                        }                        grid.rect(x, y = (nc - i + 0.5)/nc, width = 1/n,                           height = 1/nc, gp = do.call("gpar",                             c(list(fill = fill), gp)))                        if (flag)                           gp$col = NULL                      }                      else {                        r = rle(value[index, i])                        fill = map_to_colors(color_mapping, r$values)                        if (is.null(gp$col))                           gp$col = fill                        grid.rect(cumsum(r$lengths)/n, y = (nc -                           i + 0.5)/nc, width = r$length/n, height = 1/nc,                           just = "right", gp = do.call("gpar",                             c(list(fill = fill), gp)))                      }                      if (!is.null(pch)) {                        l = !is.na(pch[, i])                        if (any(l)) {                          if (is.character(pch)) {                            text_gp = subset_gp(pt_gp, i)                            text_gp$fontsize = convertHeight({                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, "pt", valueOnly = TRUE)                            grid.text(pch[l, i], x = x[l], y = rep((nc -                               i + 0.5)/nc, sum(l)), gp = text_gp)                          }                          else {                            grid.points(x[l], y = rep((nc - i +                               0.5)/nc, sum(l)), pch = pch[l,                               i], size = {                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, gp = subset_gp(pt_gp, i))                          }                        }                      }                    }                  }                  else {                    if (color_mapping@type == "continuous" ||                       !is.null(gp$col)) {                      fill = map_to_colors(color_mapping, value[index])                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(x, y = 0.5, width = 1/n, height = 1,                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    else {                      r = rle(value[index])                      fill = map_to_colors(color_mapping, r$values)                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(cumsum(r$lengths)/n, y = 0.5,                         width = r$length/n, height = 1, just = "right",                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    if (!is.null(pch)) {                      pch = pch[index]                      pt_size = pt_size[index]                      pt_gp = subset_gp(pt_gp, index)                      l = !is.na(pch)                      if (any(l)) {                        if (is.character(pch)) {                          text_gp = subset_gp(pt_gp, which(l))                          text_gp$fontsize = convertHeight(pt_size[l],                             "pt", valueOnly = TRUE)                          grid.text(pch[l], x = x[l], y = rep(0.5,                             sum(l)), gp = text_gp)                        }                        else {                          grid.points(x[l], y = rep(0.5, sum(l)),                             pch = pch[l], size = pt_size[l],                             gp = subset_gp(pt_gp, which(l)))                        }                      }                    }                  }                  if (border)                     grid.rect(gp = gpar(fill = "transparent"))                }, subset_rule = list(value = function (x, i)                 x[i]), subsettable = TRUE, data_scale = c(0.5,                 1.5), extended = c(0, 0, 0, 0), show_name = TRUE),             show_legend = FALSE, which = "column", name_to_data_vp = FALSE,             name_param = list(show = TRUE, label = " ", x = list(                list(1, list(list(1, NULL, 0L), list(1, NULL,                   7L)), 201L)), y = 0.5, offset = 1, just = "left",                 gp = list(lineheight = 0.9), rot = 0, side = "right"),             is_anno_matrix = FALSE, color_is_random = FALSE,             width = 1, height = 5, extended = c(0, 0, 0, 2.17686666666666            ), subsettable = TRUE)), anno_size = 5, which = "column",         width = 1, height = 5, gap = 1, subsettable = TRUE, extended = c(0,         0, 0, 2.17686666666666), param = list(simple_anno_size = 5,             simple_anno_size_adjust = FALSE, is_height_set = FALSE,             is_width_set = FALSE, is_annotation_height_set = FALSE,             is_annotation_width_set = FALSE)), bottom_annotation_param = list(        height = 6), left_annotation = NULL, left_annotation_param = list(        width = 0), right_annotation = new("HeatmapAnnotation",         name = "heatmap_annotation_2", anno_list = list(domain_color = new("SingleAnnotation",             name = "domain_color", label = "domain_color", color_mapping = new("ColorMapping",                 colors = c(`1` = "#5A5156FF", `2` = "#E4E1E3FF",                 `3` = "#F6222EFF", `4` = "#FE00FAFF", `5` = "#16FF32FF",                 `6` = "#3283FEFF", `7` = "#FEAF16FF"), levels = c("1",                 "2", "3", "4", "5", "6", "7"), col_fun = function ()                 NULL, type = "discrete", name = "domain_color",                 na_col = "#BEBEBEFF", full_col = c(`1` = "#5A5156FF",                 `2` = "#E4E1E3FF", `3` = "#F6222EFF", `4` = "#FE00FAFF",                 `5` = "#16FF32FF", `6` = "#3283FEFF", `7` = "#FEAF16FF",                 `8` = "#B00068FF", `9` = "#1CFFCEFF", `10` = "#90AD1CFF",                 `11` = "#2ED9FFFF", `12` = "#DEA0FDFF", `13` = "#AA0DFEFF",                 `14` = "#F8A19FFF", `15` = "#325A9BFF", `16` = "#C4451CFF",                 `17` = "#1C8356FF", `18` = "#85660DFF", `19` = "#B10DA1FF",                 `20` = "#FBE426FF", `21` = "#1CBE4FFF", `22` = "#FA0087FF",                 `23` = "#FC1CBFFF", `24` = "#F7E1A0FF", `25` = "#C075A6FF",                 `26` = "#782AB6FF", `27` = "#AAF400FF", `28` = "#BDCDFFFF"                )), legend_param = list(), fun = new("AnnotationFunction",                 which = "row", fun_name = "anno_simple", width = 5,                 height = 1, n = 7L, var_env = <environment>,                 fun = function (index, k = 1, n = 1)                 {                  n = length(index)                  y = (n - seq_len(n) + 0.5)/n                  if (is.matrix(value)) {                    nc = ncol(value)                    pch = pch[index, , drop = FALSE]                    for (i in seq_len(nc)) {                      if (color_mapping@type == "continuous" ||                         !is.null(gp$col)) {                        fill = map_to_colors(color_mapping, value[index,                           i])                        flag = 0                        if (is.null(gp$col)) {                          gp$col = fill                          flag = 1                        }                        grid.rect(x = (i - 0.5)/nc, y, height = 1/n,                           width = 1/nc, gp = do.call("gpar",                             c(list(fill = fill), gp)))                        if (flag)                           gp$col = NULL                      }                      else {                        r = rle(value[index, i])                        fill = map_to_colors(color_mapping, r$values)                        if (is.null(gp$col))                           gp$col = fill                        grid.rect(x = (i - 0.5)/nc, y = 1 - cumsum(r$lengths)/n,                           height = r$length/n, width = 1/nc,                           just = "bottom", gp = do.call("gpar",                             c(list(fill = fill), gp)))                      }                      if (!is.null(pch)) {                        l = !is.na(pch[, i])                        if (any(l)) {                          if (is.character(pch)) {                            text_gp = subset_gp(pt_gp, i)                            text_gp$fontsize = convertHeight({                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, "pt", valueOnly = TRUE)                            grid.text(pch[l, i], x = rep((i -                               0.5)/nc, sum(l)), y = y[l], gp = text_gp)                          }                          else {                            grid.points(x = rep((i - 0.5)/nc,                               sum(l)), y = y[l], pch = pch[l,                               i], size = {                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, gp = subset_gp(pt_gp, i))                          }                        }                      }                    }                  }                  else {                    if (color_mapping@type == "continuous" ||                       !is.null(gp$col)) {                      fill = map_to_colors(color_mapping, value[index])                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(x = 0.5, y, height = 1/n, width = 1,                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    else {                      r = rle(value[index])                      fill = map_to_colors(color_mapping, r$values)                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(x = 0.5, y = 1 - cumsum(r$lengths)/n,                         height = r$length/n, width = 1, just = "bottom",                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    if (!is.null(pch)) {                      pch = pch[index]                      pt_size = pt_size[index]                      pt_gp = subset_gp(pt_gp, index)                      l = !is.na(pch)                      if (any(l)) {                        if (is.character(pch)) {                          text_gp = subset_gp(pt_gp, which(l))                          text_gp$fontsize = convertHeight(pt_size[l],                             "pt", valueOnly = TRUE)                          grid.text(pch[l], x = rep(0.5, sum(l)),                             y = y[l], gp = text_gp)                        }                        else {                          grid.points(x = rep(0.5, sum(l)), y = y[l],                             pch = pch[l], size = pt_size[l],                             gp = subset_gp(pt_gp, which(l)))                        }                      }                    }                  }                  if (border)                     grid.rect(gp = gpar(fill = "transparent"))                }, subset_rule = list(value = function (x, i)                 x[i]), subsettable = TRUE, data_scale = c(0.5,                 1.5), extended = c(0, 0, 0, 0), show_name = TRUE),             show_legend = FALSE, which = "row", name_to_data_vp = FALSE,             name_param = list(show = TRUE, label = "domain_color",                 x = 0.5, y = list(list(1, list(list(0, NULL,                   0L), list(-1, NULL, 7L)), 201L)), offset = 1,                 just = "right", gp = list(lineheight = 0.9),                 rot = 90, side = "bottom"), is_anno_matrix = FALSE,             color_is_random = FALSE, width = 5, height = 1, extended = c(26.4084666666667,             0, 0, 0), subsettable = TRUE), layer_anno = new("SingleAnnotation",             name = "layer_anno", label = "layer_anno", color_mapping = new("ColorMapping",                 colors = c(L1 = "#F0027FFF", `L2/3` = "#50DDACFF",                 `L3/4` = "#8278B0FF", L5 = "#FFD700FF", L6 = "#FF7F00FF",                 WM = "#1A1A1AFF"), levels = c("L1", "L2/3", "L3/4",                 "L5", "L6", "WM"), col_fun = function ()                 NULL, type = "discrete", name = "layer_anno",                 na_col = "#BEBEBEFF", full_col = c(L1 = "#F0027FFF",                 L2 = "#377EB8FF", L3 = "#4DAF4AFF", L4 = "#984EA3FF",                 L5 = "#FFD700FF", L6 = "#FF7F00FF", WM = "#1A1A1AFF",                 `NA` = "#FFFFFF00", WM2 = "#666666FF", `L1/2` = "#BF3889FF",                 `L2/3` = "#50DDACFF", `L3/4` = "#8278B0FF", `L4/5` = "#BD8339FF",                 `L5/6` = "#FFB300FF", `L6/WM` = "#7A3D00FF")),             legend_param = list(), fun = new("AnnotationFunction",                 which = "row", fun_name = "anno_simple", width = 5,                 height = 1, n = 7L, var_env = <environment>,                 fun = function (index, k = 1, n = 1)                 {                  n = length(index)                  y = (n - seq_len(n) + 0.5)/n                  if (is.matrix(value)) {                    nc = ncol(value)                    pch = pch[index, , drop = FALSE]                    for (i in seq_len(nc)) {                      if (color_mapping@type == "continuous" ||                         !is.null(gp$col)) {                        fill = map_to_colors(color_mapping, value[index,                           i])                        flag = 0                        if (is.null(gp$col)) {                          gp$col = fill                          flag = 1                        }                        grid.rect(x = (i - 0.5)/nc, y, height = 1/n,                           width = 1/nc, gp = do.call("gpar",                             c(list(fill = fill), gp)))                        if (flag)                           gp$col = NULL                      }                      else {                        r = rle(value[index, i])                        fill = map_to_colors(color_mapping, r$values)                        if (is.null(gp$col))                           gp$col = fill                        grid.rect(x = (i - 0.5)/nc, y = 1 - cumsum(r$lengths)/n,                           height = r$length/n, width = 1/nc,                           just = "bottom", gp = do.call("gpar",                             c(list(fill = fill), gp)))                      }                      if (!is.null(pch)) {                        l = !is.na(pch[, i])                        if (any(l)) {                          if (is.character(pch)) {                            text_gp = subset_gp(pt_gp, i)                            text_gp$fontsize = convertHeight({                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, "pt", valueOnly = TRUE)                            grid.text(pch[l, i], x = rep((i -                               0.5)/nc, sum(l)), y = y[l], gp = text_gp)                          }                          else {                            grid.points(x = rep((i - 0.5)/nc,                               sum(l)), y = y[l], pch = pch[l,                               i], size = {                              if (length(pt_size) == 1)                                 pt_size                              else pt_size[i]                            }, gp = subset_gp(pt_gp, i))                          }                        }                      }                    }                  }                  else {                    if (color_mapping@type == "continuous" ||                       !is.null(gp$col)) {                      fill = map_to_colors(color_mapping, value[index])                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(x = 0.5, y, height = 1/n, width = 1,                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    else {                      r = rle(value[index])                      fill = map_to_colors(color_mapping, r$values)                      if (is.null(gp$col))                         gp$col = fill                      grid.rect(x = 0.5, y = 1 - cumsum(r$lengths)/n,                         height = r$length/n, width = 1, just = "bottom",                         gp = do.call("gpar", c(list(fill = fill),                           gp)))                    }                    if (!is.null(pch)) {                      pch = pch[index]                      pt_size = pt_size[index]                      pt_gp = subset_gp(pt_gp, index)                      l = !is.na(pch)                      if (any(l)) {                        if (is.character(pch)) {                          text_gp = subset_gp(pt_gp, which(l))                          text_gp$fontsize = convertHeight(pt_size[l],                             "pt", valueOnly = TRUE)                          grid.text(pch[l], x = rep(0.5, sum(l)),                             y = y[l], gp = text_gp)                        }                        else {                          grid.points(x = rep(0.5, sum(l)), y = y[l],                             pch = pch[l], size = pt_size[l],                             gp = subset_gp(pt_gp, which(l)))                        }                      }                    }                  }                  if (border)                     grid.rect(gp = gpar(fill = "transparent"))                }, subset_rule = list(value = function (x, i)                 x[i]), subsettable = TRUE, data_scale = c(0.5,                 1.5), extended = c(0, 0, 0, 0), show_name = TRUE),             show_legend = FALSE, which = "row", name_to_data_vp = FALSE,             name_param = list(show = TRUE, label = "layer_anno",                 x = 0.5, y = list(list(1, list(list(0, NULL,                   0L), list(-1, NULL, 7L)), 201L)), offset = 1,                 just = "right", gp = list(lineheight = 0.9),                 rot = 90, side = "bottom"), is_anno_matrix = FALSE,             color_is_random = FALSE, width = 5, height = 1, extended = c(21.7306333333333,             0, 0, 0), subsettable = TRUE)), anno_size = c(5,         5), which = "row", width = 10.3514598035146, height = 1,         gap = c(1, 1), subsettable = TRUE, extended = c(26.4084666666667,         0, 0, 0), param = list(simple_anno_size = 5, simple_anno_size_adjust = FALSE,             is_height_set = FALSE, is_width_set = FALSE, is_annotation_height_set = FALSE,             is_annotation_width_set = FALSE)), right_annotation_param = list(        width = 11.3514598035146), heatmap_param = list(width = 1,         height = 1, show_heatmap_legend = TRUE, use_raster = FALSE,         raster_device = "CairoPNG", raster_quality = 1, raster_device_param = list(),         raster_resize_mat = FALSE, raster_by_magick = TRUE, verbose = FALSE,         calling_env = <environment>, show_parent_dend_line = TRUE),     layout = list(layout_size = list(column_title_top_height = 0,         column_dend_top_height = 0, column_anno_top_height = 0,         column_names_top_height = 0, column_title_bottom_height = 0,         column_dend_bottom_height = 0, column_anno_bottom_height = 0,         column_names_bottom_height = 0, row_title_left_width = 0,         row_dend_left_width = 0, row_names_left_width = 0, row_dend_right_width = 0,         row_names_right_width = 0, row_title_right_width = 0,         row_anno_left_width = 0, row_anno_right_width = 0), layout_index = logical(0),         graphic_fun_list = list(), initialized = FALSE)))
62: print.default(p)
63: print(p)
64: .f(.x[[i]], ...)
65: map(.x, .f, ...)
66: walk(k_list, registration_one_k)
An irrecoverable exception occurred. R is aborting now ...
/cm/shared/apps/sge/sge-8.1.9//default/spool/compute-149/job_scripts/1284209: line 26: 33982 Segmentation fault      (core dumped) Rscript 01_layer_correlation_annotation.R
**** Job ends ****
Wed Dec  7 13:58:57 EST 2022
